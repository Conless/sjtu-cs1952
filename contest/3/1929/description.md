## 请务必认真阅读本题题面后再开始尝试本次机考 B 卷。

> 上周三机考之后，助教们在讨论后面几次机考的安排，发现机考一共五次，然而只安排了四位 B 卷的出题人。某助教 (以下记作 A) 本来有一个想法可以出，但是感觉一周可能来不及把题出完。于是 A 决定摆烂，出一套提交答案题，然后题面直接瞎写个故事完事，反正没人知道交什么才能有分。
>
> 然而，在某天的中午，A 出去吃饭了，你发现助教的笔记本放在机房的桌子上，没锁屏。A 电脑的桌面上有一大堆以题号命名的文件夹。你悄悄地用 A 的帐号登上 jBox (这样 A 就不知道是谁干的坏事了)，上传了所有题目数据，创建了一个分享。(**分享的链接是 <https://jbox.sjtu.edu.cn/l/TODO>。**)
>
> 拿到了题目数据的你能 AK 这次机考吗?

本次机考以 **提交答案题** 为主。除 1921 外，1922 至 1928 均为提交答案题。与传统的提交代码题不同，你提交的内容不是一份 C++ 代码，而是一个任意字符串。这个字符串会被交给称为 SPJ (Special Judge) 的程序进行评测。SPJ 的源代码均已给出，详情见下发文件各个题目目录下的 spj.cpp。

SPJ 会对你输入的文本有一定的要求。你的任务就是，理解 SPJ 代码中对你提交的答案的要求，并构造出一份能够通过 SPJ 的答案。提交时，只需提交答案即可,「代码语言」一栏没有作用，可以选择任意选项。

你可以在本机上测试 SPJ 对你答案的评判。首先你需要编译 SPJ:

```
cd 1922
g++ spj.cpp -o spj
```

假设你的答案存储在 myanswer.txt 文件中，则可以输入:

```
./spj 1.in myanswer.txt 1.ans score.txt message.txt
```

运行 SPJ 程序。SPJ 运行后，会在 score.txt 中写入一个分数 (0.0 为零分，1.0 为满分); 同时可能会在 message.txt 中写入一些评测机返回给你的消息。这个消息会呈现在 OJ Web 的评测结果页面上。

1922 题的 spj.cpp 中包含对 SPJ 更具体的说明，你可以参考阅读。

本题 (1929) 并不是一道真正的题目，不计入分数。你可以用这道题目测试 OJ 的 C++ 运行环境下你提交的程序的行为。你提交的程序输出的内容将直接显示在评测详情页面上。由于本次机考可能会利用一些 C/C++ 程序的未定义行为 (undefined behavior) 和/或实现定义行为 (implementation-defined behavior)，你的电脑上程序的运行结果确实有可能与 OJ 上不完全相同。经过助教测试，在 Ubuntu 18.04, Ubuntu 20.04, Ubuntu 22.04 和 Arch Linux 环境下，在助教测试的程序上表现的行为均与 OJ 上一致，因此使用这些环境直接运行程序大概率没有问题。你可以尝试提交以下代码:

```c
#include <stdio.h>
#include <stdlib.h>

int main () {
  srand(20230711);
  printf("%d\n", rand());
  return 0;
}
```

(你将获得 0 分。此题无论提交任何代码都会获得 0 分。)

以下是一些对整场机考的提示:

- 题目顺序与难度没有必然联系，有些题目卡住了可能很久都想不出来，所以在一道题上如果卡住了，或者认为这题太无聊，可以考虑先看看其他题目。
- SPJ 源代码的真正含义可能与你的第一直觉不同，源代码表面的形式甚至可能是故意的误导。
- 使用 -Wall 编译选项 (启用更多的编译器警告) 也许能发现源代码的一些异常之处。
- 虽然题目背景是一个虚假的故事，但是所有题目确实是在过去一周之内编写完成的。
- 你可以使用任何方法获得分数，明令禁止的除外。题面只是一个提示，不一定要遵循题面上给出的信息。
- 不可以上网查阅资料；维基百科、C++ Reference 及题目中明确说明的除外。
- 不可以攻击 OJ 平台 (包括但不限于 OJ Web 系统、评测机沙箱、评测调度机等)。
- 机考中没有需要提交很多次的题目，短时间提交大量评测请求只会导致 OJ 负载过重。作为参考，你不应该一道题目提交超过 42 次。如果遇到特殊情况请联系助教。
- 虽然本次机考的形式与 CTF 有相似之处，但这不是传统的 CTF。你只需要运用在程序设计、数据结构课程中学到的知识就可以解决所有问题，不需要 CTF 中所使用的二进制攻击技巧。(如果你不知道什么是 CTF，可以直接忽略本条内容。)
